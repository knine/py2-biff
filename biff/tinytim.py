#!/usr/bin/env python

import math
import numpy
import os
import sys
import time
import yaml

from pyraf import iraf
from termcolor import colored

class Resample:
    """
    A class to resample a PSF model generated by Tiny Tim.

    Attributes
    ----------
        datapath:
            Directory path to BIFF program to reference data files.
            
    Methods
    -------
        WritePSFs(self, **kwargs):
            Creates and writes resampled primary and secondary PSF model files.
    """

    def __init__(self,datapath):
        """
        Constructs all the necessary attributes for resample object.

        Parameters
        ----------
            datapath:
                Directory path to BIFF program to reference data files.
        """

        self.samplelist = datapath + '/data/ResampleList.yaml'
        self.psfinfo = datapath + '/data/nicmos.yaml'

        try:
            with open(self.psfinfo,'r') as file:
                info = yaml.load(file, Loader=yaml.FullLoader)
                self.nbin = info['nicmos1']['nbin']
                self.cols = info['nicmos1']['cols']
                self.rows = info['nicmos1']['rows']
        except IOError:
            print(colored('ERROR: ' + self.psfinfo + ' could not be found.\n','red'))
            GoOn = raw_input(colored('Press Enter To Continue...','green'))

        if not os.path.exists(os.getcwd() + '/psf'):
            os.makedirs(os.getcwd() + '/psf')

        # TODO: Verify the object00.fits file exists

    def WritePSFs(self, **kwargs):
        """
        Creates and writes resampled primary and secondary PSF model files.

        Parameters
        ----------
            primary: 
                [true|false] - Boolean to determine if primary PSF files are created.
            secondary:
                [true|false] - Boolean to determine if secondary PSF files are created.

        Returns
        -------
        None
        """

        print('\n' + '#' * 60 + '\n')

        iraf.dataio()
        iraf.dataio.setParam('wtextimage.header','no')
        iraf.dataio.setParam('wtextimage.format','15.8g')
        iraf.dataio.setParam('wtextimage.maxlinelen','20')

        try:
            with open(self.samplelist,'r') as file:
                InputList = yaml.load(file,Loader=yaml.FullLoader)
        except IOError:
            print(colored('ERROR: ' + self.samplelist + ' could not be found.\n','red'))
            GoOn = raw_input(colored('Press Enter To Continue...','green'))

	LogFile = open('logs/ResamplePSF.log','w')

        for InputLine in InputList:

            print('Creating PSF Model:\t\t\t\t\t[' + InputLine['PrimaryOut'][5:7] + ']\r'),
            sys.stdout.flush()
            
            LogFile.write('%s ---> %s\n' % (InputLine['WTextIn'],InputLine['WTextOut']))
            LogFile.write('-' * len(InputLine['WTextIn'] + ' ---> ' + InputLine['WTextOut']) + '\n')
            LogFile.write('Number of Columns: %d\n' % InputLine['ncol'])
            LogFile.write('Number of Rows: %d\n' % InputLine['nrow'])
            LogFile.flush()

            WTextIn = os.getcwd() + '/' + str(InputLine['WTextIn'])
            WTextOut = os.getcwd() + '/' + str(InputLine['WTextOut'])
            iraf.wtextimage(WTextIn, WTextOut)

            InputPSF = numpy.zeros((self.cols*self.nbin,self.rows*self.nbin))
            PSFValue = open(InputLine['WTextOut'], 'r')

            # Loop through the number of columns and rows for the InputPSF and put those values in a matrix array
            # TODO: There is likely a better NumPy way to do this.
            # TODO: Also bad object00.fits (for input) dies here, could
            #       use a try / catch.
            for j in range(1,InputLine['nrow'] + 1):
                for i in range(1,InputLine['ncol'] + 1):
                    InputPSF[i,j] = float(PSFValue.readline())

            InputSum = numpy.add.reduce(numpy.add.reduce(InputPSF))

            xdim = InputLine['ncol'] // self.nbin
            ydim = InputLine['nrow'] // self.nbin

            LogFile.write('PSF x-dimension: %d\n' % xdim)
            LogFile.write('PSF y-dimension: %d\n' % ydim)

            OutputPSF = numpy.zeros((self.cols,self.rows))

            # Loop through the number of columns and rows for the OutputPSF
            for j in range(1, ydim + 1):
                for i in range(1, xdim + 1):

                    nxcount = self.nbin*i                                   # Low x value of array slice
                    nxlow = nxcount-(self.nbin - 1)                         # High x value of array slice
                    nycount = self.nbin*j                                   # Low y value of array slice
                    nylow = nycount-(self.nbin - 1)                         # High y value of array slice

                    # Slice off a 10 x 10 part of the InputPSF and make it one pixel of the OutputPSF
                    OutputPSF[i,j] = numpy.add.reduce(numpy.add.reduce(InputPSF[nxlow:nxcount+1,nylow:nycount+1]))

            OutputSum = numpy.add.reduce(numpy.add.reduce(OutputPSF))

            # TODO find a way to do this loop once and write once or twice as needed.

            if 'primary' in kwargs:
                with open('psf/' + InputLine['PrimaryOut'],'w') as PrimaryOutputFile: 
                    [PrimaryOutputFile.write(str(OutputPSF[i,j]) + '\n') for j in range(1, ydim + 1) for i in range(1, xdim + 1)]
		LogFile.write('%s ---> %s\n' % (InputLine['WTextOut'],InputLine['PrimaryOut']))

	    if 'secondary' in kwargs:
                with open('psf/' + InputLine['SecondaryOut'],'w') as SecondaryOutputFile:
                    [SecondaryOutputFile.write(str(OutputPSF[i,j]) + '\n') for j in range(1, ydim + 1) for i in range(1, xdim + 1)]
                LogFile.write('%s ---> %s\n' % (InputLine['WTextOut'],InputLine['SecondaryOut']))
                           
            os.remove(WTextOut)

            LogFile.write('Input Sum: %f' % InputSum + '\n')
            LogFile.write('Output Sum: %f' % OutputSum + '\n')
            LogFile.write('\n')
	    LogFile.flush()

	LogFile.close()
	print('Creating PSF Model:\t\t\t\t\t[OK]\n')
	print('#' * 60)

class TinyTim():
    """
    Python wrapper class to run STScI Tiny Tim PSF model program.

    Attributes
    ----------
        param: dict
            Dictionary containing Tiny Tim configuration.
    
    Methods
    -------
        tiny1(self):
            Runs the tiny1 STScI program.
        tiny1(self)
            Runs the tiny2 STScI program.
    """

    def __init__(self,param):
        """
        Constructs all the necessary parameters for TinyTim object.

        Parameters
        ----------
            param: dict
                Dictionary containing Tiny Tim configuration.
        """
        os.environ['TINYTIM'] = param['path']
        self.tiny1out = param['outfile']

    def tiny1(self):
        """
        Runs the tiny1 STScI program.

        Returns
        ------
        None
        """
        print('\n' + '#' * 60 + '\n')
        print('Running tiny1...')
        os.system('env tiny1 ' + self.tiny1out)

        # TODO: A list using pexpect to input values from biff.yaml.
        #       Print out values before running.

        print('\n' + '#' * 60 + '\n')
        GoOn = raw_input('Press Enter To Continue...')

    def tiny2(self):
        """
        Runs the tiny1 STScI program.

        Returns
        -------
        None
        """
        print('\n' + '#' * 60 + '\n')
        print('Running tiny2 On Parameter File...\n')

        # TODO: Verify the file self.tiny1out exists

        os.system('env tiny2 ' + self.tiny1out)
        GoOn = raw_input('Press Enter To Continue...')
